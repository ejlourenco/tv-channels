[{"C:\\dev\\tv-channels\\src\\index.tsx":"1","C:\\dev\\tv-channels\\src\\reportWebVitals.ts":"2","C:\\dev\\tv-channels\\src\\App.tsx":"3","C:\\dev\\tv-channels\\src\\components\\DayNavigator.tsx":"4","C:\\dev\\tv-channels\\src\\components\\HourNavigator.tsx":"5","C:\\dev\\tv-channels\\src\\components\\ChannelBlock.tsx":"6","C:\\dev\\tv-channels\\src\\components\\ChannelShows.tsx":"7","C:\\dev\\tv-channels\\src\\components\\ShowBlock.tsx":"8","C:\\dev\\tv-channels\\src\\utils\\Utils.tsx":"9","C:\\dev\\tv-channels\\src\\serviceWorkerRegistration.ts":"10"},{"size":818,"mtime":1615651507761,"results":"11","hashOfConfig":"12"},{"size":425,"mtime":499162500000,"results":"13","hashOfConfig":"12"},{"size":6462,"mtime":1615727441224,"results":"14","hashOfConfig":"12"},{"size":732,"mtime":1613938341711,"results":"15","hashOfConfig":"12"},{"size":2062,"mtime":1614639111196,"results":"16","hashOfConfig":"12"},{"size":1052,"mtime":1615727441224,"results":"17","hashOfConfig":"12"},{"size":3571,"mtime":1614813492980,"results":"18","hashOfConfig":"12"},{"size":1868,"mtime":1615727441224,"results":"19","hashOfConfig":"12"},{"size":4541,"mtime":1615652759989,"results":"20","hashOfConfig":"12"},{"size":5256,"mtime":1615650976108,"results":"21","hashOfConfig":"12"},{"filePath":"22","messages":"23","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"24"},"v0ozz6",{"filePath":"25","messages":"26","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"24"},{"filePath":"27","messages":"28","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"24"},{"filePath":"29","messages":"30","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"24"},{"filePath":"31","messages":"32","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"24"},{"filePath":"33","messages":"34","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"24"},{"filePath":"35","messages":"36","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"37","usedDeprecatedRules":"24"},{"filePath":"38","messages":"39","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"40","messages":"41","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"42","usedDeprecatedRules":"24"},{"filePath":"43","messages":"44","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"24"},"C:\\dev\\tv-channels\\src\\index.tsx",[],["45","46"],"C:\\dev\\tv-channels\\src\\reportWebVitals.ts",[],"C:\\dev\\tv-channels\\src\\App.tsx",[],"C:\\dev\\tv-channels\\src\\components\\DayNavigator.tsx",[],"C:\\dev\\tv-channels\\src\\components\\HourNavigator.tsx",[],"C:\\dev\\tv-channels\\src\\components\\ChannelBlock.tsx",[],"C:\\dev\\tv-channels\\src\\components\\ChannelShows.tsx",["47","48"],"import React, { useEffect, useRef, useState } from \"react\";\r\nimport { Channel, Interval, Show, TimeBlock } from \"../model/Model\";\r\nimport { ShowBlock } from \"./ShowBlock\";\r\nimport Moment from \"moment\";\r\nimport { getChannelShows, getInterval, useOnScreen } from \"../utils/Utils\";\r\nimport \"./ChannelShows.css\";\r\n\r\nconst getShowPeriod = (show: Show): string => {\r\n  return `${Moment(show.StartDate).format(\"HH:mm\")}-${Moment(\r\n    show.EndDate\r\n  ).format(\"HH:mm\")}`;\r\n};\r\n\r\nconst getWidthByShow = (\r\n  program: Show,\r\n  interval: Interval,\r\n  hourInterval: number\r\n) => {\r\n  const { StartDate, EndDate } = interval;\r\n  let programStartDate = Moment(program.StartDate);\r\n  let programEndDate = Moment(program.EndDate);\r\n  if (programStartDate.isBefore(StartDate)) {\r\n    programStartDate = Moment(StartDate);\r\n  } else if (programEndDate.isAfter(EndDate)) {\r\n    programEndDate = Moment(EndDate);\r\n  }\r\n  const durationMinutes = Moment(programEndDate).diff(\r\n    programStartDate,\r\n    \"minute\"\r\n  );\r\n  const percentageDuration =\r\n    durationMinutes === 0 ? 0 : (100 * durationMinutes) / hourInterval / 60;\r\n  return `${percentageDuration}%`;\r\n};\r\n\r\nexport const ChannelShows = ({\r\n  channelHeight,\r\n  channel,\r\n  timeBlock,\r\n  highlight,\r\n  onWatchShow,\r\n}: {\r\n  channelHeight: string;\r\n  channel: Channel;\r\n  timeBlock: TimeBlock;\r\n  highlight: string;\r\n  onWatchShow: (channel: Channel, show: Show) => any;\r\n}) => {\r\n  const [data, setData] = useState<{ shows: Show[]; days: Moment.Moment[] }>({\r\n    shows: [],\r\n    days: [],\r\n  });\r\n\r\n  const ref = useRef(null);\r\n  const isOnScreen = useOnScreen(ref);\r\n\r\n  const interval = getInterval(timeBlock);\r\n\r\n  useEffect(() => {\r\n    const fetchChannelShows = async (day: Moment.Moment) => {\r\n      const shows = await getChannelShows(channel, day);\r\n      setData((data) => ({\r\n        ...data,\r\n        days: [...data.days, day],\r\n        shows: [...data.shows, ...(shows || [])],\r\n      }));\r\n    };\r\n    if (isOnScreen) {\r\n      const { StartDate, EndDate } = interval;\r\n      let date = Moment(StartDate).startOf(\"day\");\r\n      while (date.isBefore(Moment(EndDate).endOf(\"day\"))) {\r\n        if (!data.days.find((d) => d.isSame(date, \"day\"))) {\r\n          const dateDay = date.startOf(\"day\");\r\n          fetchChannelShows(dateDay);\r\n        }\r\n        date = Moment(date).add(1, \"day\");\r\n      }\r\n    }\r\n  }, [timeBlock, isOnScreen]);\r\n\r\n  const getVisibleShows = (): Show[] => {\r\n    const { StartDate, EndDate } = getInterval(timeBlock);\r\n    let shows = data.shows\r\n      .filter(\r\n        (show) =>\r\n          !Moment(show.EndDate).isBefore(StartDate) &&\r\n          !Moment(show.StartDate).isAfter(EndDate)\r\n      )\r\n      .sort((a, b) =>\r\n        Moment(a.StartDate).isBefore(Moment(b.StartDate)) ? -1 : 1\r\n      );\r\n    return shows;\r\n  };\r\n\r\n  return (\r\n    <div ref={ref} className=\"ChannelShows__Content\">\r\n      {isOnScreen &&\r\n        getVisibleShows().map((show) => (\r\n          <ShowBlock\r\n            key={show.Id}\r\n            title={getShowPeriod(show) + \" \" + show.Title}\r\n            synopsis={show.Synopsis}\r\n            participants={show.Participants}\r\n            width={getWidthByShow(show, interval, timeBlock.Hours)}\r\n            channelHeight={channelHeight}\r\n            onWatchShow={() => onWatchShow(channel, show)}\r\n            isPlayButtonVisible={\r\n              Moment(show.StartDate).isBefore(Moment()) &&\r\n              Moment(show.StartDate).isAfter(Moment().add(-1, \"d\"))\r\n            }\r\n            highlight={highlight}\r\n          ></ShowBlock>\r\n        ))}\r\n    </div>\r\n  );\r\n};\r\n","C:\\dev\\tv-channels\\src\\components\\ShowBlock.tsx",[],"C:\\dev\\tv-channels\\src\\utils\\Utils.tsx",["49","50"],"import {\r\n  Channel,\r\n  Filter,\r\n  FilterOption,\r\n  Interval,\r\n  Show,\r\n  TimeBlock,\r\n} from \"../model/Model\";\r\nimport Moment from \"moment\";\r\nimport { useEffect, useState } from \"react\";\r\n\r\nconst exaustODataEndpoint = async (url: string, all = true): Promise<any> => {\r\n  const response = await fetch(url);\r\n  const decodedResponse = await response.json();\r\n  const data = decodedResponse.value;\r\n  const nextLink: string = decodedResponse[\"odata.nextLink\"];\r\n  if (nextLink && all) {\r\n    const link = nextLink.startsWith(\"http://\")\r\n      ? nextLink.split(\"http://\").join(\"https://\")\r\n      : nextLink;\r\n    const nextData = await exaustODataEndpoint(link, all);\r\n    return [...data, ...nextData];\r\n  } else {\r\n    return data;\r\n  }\r\n};\r\n\r\nexport const getChannels = async (): Promise<Channel[]> => {\r\n  let channels: Channel[] = await exaustODataEndpoint(\r\n    \"https://ott.online.meo.pt/catalog/v9/Channels?UserAgent=IPTV_OFR_AND&OfferId=21600543&$orderby=ChannelPosition%20asc&$inlinecount=allpages\",\r\n    true\r\n  );\r\n  // channels = [channels[0], channels[1], channels[2], channels[3], channels[4]];\r\n  return channels;\r\n\r\n  // const programsByChannel = await Promise.all(\r\n  //   channels.map((channel: any) => fetchChannelData(channel, data.date))\r\n  // );\r\n  // const dataByChannel = programsByChannel.reduce<DataByChannel>(\r\n  //   (acc, pro, index) => ({ ...acc, [channels[index].Id]: pro }),\r\n  //   {}\r\n  // );\r\n};\r\n\r\nexport const getChannelShows = async (\r\n  channel: Channel,\r\n  day: Moment.Moment\r\n): Promise<Show[]> => {\r\n  const dateFormat = \"YYYY-MM-DDTHH:mm:ss\";\r\n  const startDate = Moment(day).add(-1, \"day\").endOf(\"day\").format(dateFormat);\r\n  const endDate = Moment(day).add(1, \"day\").startOf(\"day\").format(dateFormat);\r\n  return await exaustODataEndpoint(\r\n    `https://ott.online.meo.pt/Program/v9/Programs?UserAgent=IOS&$orderby=StartDate%20asc&$filter=CallLetter%20eq%20%27${channel.CallLetter}%27%20and%20StartDate%20gt%20datetime%27${startDate}%27%20and%20StartDate%20lt%20datetime%27${endDate}%27%20and%20IsEnabled%20eq%20true%20and%20IsBlackout%20eq%20false&$inlinecount=allpages`\r\n  );\r\n};\r\n\r\nexport const getInterval = (timeBlock: TimeBlock): Interval => {\r\n  return {\r\n    StartDate: timeBlock.StartDate,\r\n    EndDate: Moment(timeBlock.StartDate).add(timeBlock.Hours, \"hours\"),\r\n  };\r\n};\r\n\r\nexport function useOnScreen(ref: any, rootMargin = \"0px\") {\r\n  // State and setter for storing whether element is visible\r\n  const [isIntersecting, setIntersecting] = useState(false);\r\n\r\n  useEffect(() => {\r\n    const observer = new IntersectionObserver(\r\n      ([entry]) => {\r\n        // Update our state when observer callback fires\r\n        setIntersecting(\r\n          entry.isIntersecting && entry.boundingClientRect.height > 0\r\n        );\r\n      },\r\n      {\r\n        rootMargin,\r\n      }\r\n    );\r\n    if (ref.current) {\r\n      observer.observe(ref.current);\r\n    }\r\n    return () => {\r\n      if (ref.current) {\r\n        observer.unobserve(ref.current);\r\n      }\r\n    };\r\n  }, []); // Empty array ensures that effect is only run on mount and unmount\r\n\r\n  return isIntersecting;\r\n}\r\n\r\nexport const ALL_OPTION_VALUE = \"_all\";\r\nexport const ALL_OPTION: FilterOption<string> = {\r\n  value: ALL_OPTION_VALUE,\r\n  title: \"All\",\r\n};\r\n\r\nexport const DEFAULT_FILTER: Filter<string> = {\r\n  value: ALL_OPTION_VALUE,\r\n  options: [ALL_OPTION],\r\n};\r\n\r\nexport const getOptionsByValues = (\r\n  values: string[]\r\n): FilterOption<string>[] => {\r\n  // @ts-ignore\r\n  const uniqueValues: string[] = [...new Set(values)];\r\n  const options: FilterOption<string>[] = uniqueValues.map((v) => ({\r\n    value: v,\r\n    title: v,\r\n  }));\r\n  return [ALL_OPTION, ...options];\r\n};\r\n\r\nexport const getVideoUrl = (channel: Channel, show?: Show): string => {\r\n  const { FriendlyUrlName } = channel;\r\n  const { StartDate, EndDate } = show\r\n    ? show\r\n    : { StartDate: Moment(), EndDate: null };\r\n  const formattedStartDate = Moment(StartDate).format(\"YYYY-MM-DDTHH:mm:00\");\r\n  const formattedEndDate = EndDate\r\n    ? Moment(EndDate).format(\"YYYY-MM-DDTHH:mm:00\")\r\n    : \"END\";\r\n  return `http://213.13.23.76/wp/cdn-vspp-pcs1.online.meo.pt/shls/LIVE$${FriendlyUrlName}/index.m3u8?device=IOS_Live&start=${formattedStartDate}&end=${formattedEndDate}`;\r\n};\r\n\r\nexport const useDebounce = (value: string, timeout: number) => {\r\n  const [state, setState] = useState(value);\r\n\r\n  useEffect(() => {\r\n    const handler = setTimeout(() => setState(value), timeout);\r\n\r\n    return () => clearTimeout(handler);\r\n  }, [value, timeout]);\r\n\r\n  return state;\r\n};\r\n","C:\\dev\\tv-channels\\src\\serviceWorkerRegistration.ts",[],{"ruleId":"51","replacedBy":"52"},{"ruleId":"53","replacedBy":"54"},{"ruleId":"55","severity":1,"message":"56","line":72,"column":29,"nodeType":"57","messageId":"58","endLine":72,"endColumn":57},{"ruleId":"59","severity":1,"message":"60","line":79,"column":6,"nodeType":"61","endLine":79,"endColumn":29,"suggestions":"62"},{"ruleId":"59","severity":1,"message":"63","line":85,"column":32,"nodeType":"64","endLine":85,"endColumn":39},{"ruleId":"59","severity":1,"message":"65","line":88,"column":6,"nodeType":"61","endLine":88,"endColumn":8,"suggestions":"66"},"no-native-reassign",["67"],"no-negated-in-lhs",["68"],"no-loop-func","Function declared in a loop contains unsafe references to variable(s) 'date'.","ArrowFunctionExpression","unsafeRefs","react-hooks/exhaustive-deps","React Hook useEffect has missing dependencies: 'channel', 'data.days', and 'interval'. Either include them or remove the dependency array.","ArrayExpression",["69"],"The ref value 'ref.current' will likely have changed by the time this effect cleanup function runs. If this ref points to a node rendered by React, copy 'ref.current' to a variable inside the effect, and use that variable in the cleanup function.","Identifier","React Hook useEffect has missing dependencies: 'ref' and 'rootMargin'. Either include them or remove the dependency array.",["70"],"no-global-assign","no-unsafe-negation",{"desc":"71","fix":"72"},{"desc":"73","fix":"74"},"Update the dependencies array to be: [timeBlock, isOnScreen, channel, interval, data.days]",{"range":"75","text":"76"},"Update the dependencies array to be: [ref, rootMargin]",{"range":"77","text":"78"},[2360,2383],"[timeBlock, isOnScreen, channel, interval, data.days]",[3008,3010],"[ref, rootMargin]"]